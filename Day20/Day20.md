# 30天自制操作系统---第八天

## 1. 鼠标数据解读
* 鼠标被激活后会发送数据0xfa，之后每组鼠标数据都是三个字节

* 第二字节和第三字节分别关于鼠标的水平和垂直位移

* 第一字节与鼠标的状态信息有关

* 定义一个名为MOUSE_DEC的结构体:

        struct MOUSE_DEC {
            unsigned char buf[3], phase;  // buf存鼠标数据， phase存字节数量
            int x, y, btn; // x，y是相对屏幕的水平位移，btn存鼠标键的状态
        };

* 关键的数据解读代码:

        mdec->btn = mdec->buf[0] & 0x07; // 低三位与鼠标的键有关
        /* 用第一字节中对鼠标移动有反应的几位信息，
           将x和y的第8位及第8位以后全部都设成1，或全部都保留为0。*/
        mdec->x = mdec->buf[1]; 
        mdec->y = mdec->buf[2];
        if ((mdec->buf[0] & 0x10) != 0) {
            mdec->x |= 0xffffff00;
        }
        if ((mdec->buf[0] & 0x20) != 0) {
            mdec->y |= 0xffffff00;
        }
        mdec->y = - mdec->y; /* 鼠标的y方向与画面符号相反 */

* 最后利用鼠标的位移信息使鼠标移动起来

## 2. 解读asmhead程序，16位->32位的过程（重点）
* 首先进行**中断屏蔽**(设置PIC以及设置IF标志)

* **设定A20GATE**，为了让CPU能够访问1MB以上的内存空间

* 指令键盘控制电路的附属端口输出0xdf，让A20GATE信号线变成ON的状态

* 鼠标能够顺利发送数据后，采用类似键盘的方法接收鼠标的数据

* 在执行激活指令之前，电路被限制为只能使用1MB内存

* A20GATE信号线正是用来使这个电路停止从而让所有内存都可以使用的东西

* 读随意准备的GDT，将CR0寄存器的**最高位**置0(**禁止分页**)，**最低位**置1(**切换保护模式**)

* 之后需要跳转，然后将除CS外的段寄存器的值都设置为0x0008

* 然后将一些内存复制的工作

* 

## 收获
### 1. 了解一些汇编的指令
* NOP指令--让CPU休息一个时钟长的时间

* [INSTRSET "i486p"]--为了能够使用386以后的LGDT，EAX，CR0等关键字

* SHR指令--向右移位指令

* JZ和JNZ指令--条件跳转指令，根据上一个计算结果是否为零

* ALIGNB指令的--一直添加DBO，直到地址能被某个值整除

### 2. 32位模式切换中细节
* **CR0**--“control register 0”，是一个非常重要的寄存器，只有操作系统才能操作它

* **保护模式**--“protected virtual address mode”--受保护的虚拟内存地址模式

* **从前的16位模式**--“real address mode”--实际地址模式

* 通过代入CR0而切换到保护模式时，要马上执行JMP指令，为什么呢？

* 切换模式后，语言的解释发送变化。CPU加快指令的执行使用了**管道机制**(前一条指令还在执行的时候，就开始解释下一条甚至是再下一条指令)。因为模式变了，就要重新解释一遍，所以加入了JMP指令。

* 为什么段寄存器的值需要改变？

* 因为切换模式后段寄存器的意思也变了，CS保持原状是因为如果CS也变了，会造成混乱

* **系统的内存分布**如下:

    * 0x00000000 - 0x000fffff : 虽然在启动中会多次使用，但之后就变空。（1MB）
    * 0x00100000 - 0x00267fff : 用于保存软盘的内容。（1440KB）
    * 0x00268000 - 0x0026f7ff : 空（30KB）
    * 0x0026f800 - 0x0026ffff : IDT（2KB）
    * 0x00270000 - 0x0027ffff : GDT（64KB）
    * 0x00280000 - 0x002fffff : bootpack.hrb（512KB）
    * 0x00300000 - 0x003fffff : 栈及其他（1MB）
    * 0x00400000 - : 空

* **GDT0**也是一种特定的GDT。0号是空区域（null sector），不能够在那里定义段。

* 在GDT0里，写入了16位的段上限，和32位的段起始地址。

### 收获满满的一天！